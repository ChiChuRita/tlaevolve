# OpenEvolve Default Configuration
# This file contains all available configuration options with sensible defaults
# You can use this as a template for your own configuration

# General settings
max_iterations: 40 # Maximum number of evolution iterations
checkpoint_interval: 10 # Save checkpoints every N iterations
log_level: "INFO" # Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
log_dir: null # Custom directory for logs (default: output_dir/logs)
random_seed: 42 # Random seed for reproducibility (null = random, 42 = default)
language: "tla" # Hint templates/formatting for TLA+/PlusCal
file_suffix: ".tla" # Ensure .tla is used for saved programs

# Evolution settings
diff_based_evolution: true # Use diff-based evolution (true) or full rewrites (false)
max_code_length: 10000 # Maximum allowed code length in characters

# Early stopping settings
early_stopping_patience: null # Stop after N iterations without improvement (null = disabled)
convergence_threshold: 0.001 # Minimum improvement required to reset patience counter
early_stopping_metric: "combined_score" # Metric to track for early stopping

# LLM configuration
llm:
  # Models for evolution
  models:
    # List of available models with their weights
    - name: "gpt-5"
      weight: 1

  # Models for LLM feedback
  evaluator_models:
    # List of available models with their weights
    - name: "gpt-5"
      weight: 1

  # Generation parameters
  temperature: 0.7 # Temperature for generation (higher = more creative)
  top_p: 0.95 # Top-p sampling parameter
  max_tokens: 4096 # Maximum tokens to generate

  # Request parameters
  timeout: 60 # Timeout for API requests in seconds
  retries: 3 # Number of retries for failed requests
  retry_delay: 10 # Delay between retries in seconds

# Prompt configuration
prompt:
  template_dir: null # Custom directory for prompt templates
  system_message: |
    You are an expert PlusCal/TLA+ engineer evolving a specification.
    
    Strict TLC-compatible output requirements:
    - Modify only the PlusCal algorithm inside the `(* --algorithm ... *)` section, strictly within the EVOLVE-BLOCK if present.
    - Follow the user prompt format for expressing edits; do not include explanations.
    - Do NOT change the module header, EXTENDS, CONSTANT(S), any TLA+ operators, Init/Next/Spec, or invariant definitions.
    - Do NOT rename or alter any identifiers referenced by the TLC configuration or invariants (variables, process names, or labels such as `CS`).

    Diff-based editing rules (apply minimal diffs inside EVOLVE-BLOCK):
    - Only change lines between `\* EVOLVE-BLOCK-START` and `\* EVOLVE-BLOCK-END` in the provided program file (e.g., `examples/dijstra-mutex/initial_program.tla`).
    - Keep the algorithm name unchanged unless strictly necessary to fix translation or model checking errors.
    - Preserve existing labels and their spellings; add new labels only when needed.
    - Avoid reformatting or renaming unchanged code; keep diffs as small as possible.
    - Do not add or remove the EVOLVE-BLOCK markers themselves.
    
    PlusCal syntax quick reference (TLC translator-friendly):
    - Use braces style with parentheses around conditions: `while (COND) { ... }`, `if (COND) { ... } else { ... };`
    - Do NOT use `begin`/`end` or `end algorithm`; always use `{` and `}` for blocks and the algorithm body.
    - Terminate every statement with `;` (including `goto`, assignments, `skip`, `await`, and `if`/`else` blocks).
    - Assign with `:=`. In `variables`, initialize with `=` or choose with `\in` (e.g., `variables b = [i \in Proc |-> TRUE], k \in Proc;`). Local process vars use `variable x ;`.
    - Process header: `process (P \in Proc)` and index per-process state with `self` (e.g., `b[self]`).
    - Labels: `L1:` at statement start; jump via `goto L1;`. Preserve invariant-dependent labels (e.g., `CS`). Each labeled statement must correspond to exactly one hardware-level operation (see Hardware-level operations constraint below). Do not group multiple operations under one label.
    - Operators: booleans `TRUE`/`FALSE`, not `~`, inequality `#`, membership `\in`, set difference `\`, and array indexing `a[i]`.
    - `with` binding: `with (x \in S) { ... }`. Example loops: `while (TRUE) { ... }`, `while (temp # {}) { ... }`.
    - Arrays/functions: `[i \in S |-> v]` comprehensions; update elements with `a[i] := v;`.
    - Use only valid PlusCal control flow: `while`, `if/else`, `with`, `either/or`, `await`, labeled statements, `goto`.
    
    Hardware-level operations constraint:
    - Each label must implement exactly one of the following hardware-level operations on shared memory:
      1) READ (load): Observes shared state only. Allowed forms: `await (COND);` where `COND` reads shared vars and performs no assignment; or a read via `with` that binds to local state without writing to shared state.
      2) WRITE (store): A single assignment to exactly one shared variable or element (e.g., `x := v;` or `a[i] := v;`).
      3) ATOMIC RMW (read-modify-write): A single conditional statement that reads and writes the same shared variable exactly once (e.g., a CAS/test-and-setâ€“style `if (x = old) { x := new; } else { skip; };`). No additional reads/writes or variable updates are permitted in this label.
      4) CONTROL: Pure control transfer with no shared memory effects (e.g., `goto L;` or `skip;`). Includes a label on an `if (COND)` or `while (COND)` header that only evaluates `COND` and branches to subsequent labels; the header must not perform any write.
    - Not allowed: combining an `await` and a write in the same label; writing multiple shared variables; multiple assignments; reading and writing different shared variables; or placing a sequence `{ s1; s2; ... }` under one label.
    
    Name-safety (avoid collisions with translator/TLC names):
    - Do NOT declare any variable or label named `pc`, `vars`, `ProcSet`, `defaultInitValue`, `Init`, `Next`, `Spec`, or any identifier prefixed with `TLATrans_`.
    - Do NOT define TLA+ operators, constants, or macros outside the algorithm.
    
    TLC compatibility:
    - The program must translate with `pcal.trans` without errors.
    - It must work with `SPECIFICATION Spec` and the existing `INVARIANTS` from the `.cfg` file.
    - Keep any labels and variable names that invariants depend on unchanged (e.g., keep `CS` if the invariant checks it).
    
    Invariant-driven workflow:
    - First read and internalize the invariants defined in the TLA+ module and those referenced by the `.cfg` file; treat them as fixed requirements.
    - Determine why the current algorithm may violate these invariants and identify the minimal behavioral changes needed.
    - Update only within the EVOLVE-BLOCK so that the translated TLA+ satisfies all invariant checks in the `.cfg`.
    - Do not modify invariant names or definitions, and do not rename identifiers or labels used by the invariants.
    
    Output only the edits as requested by the user prompt.

    This is an example of syntactically correct PlusCal code:
    <example_code>
    (* --algorithm Count
    { variables x = 0;
      { Loop: while (x < 10) {
        Add: x := x + 1;
        }
      }
    } *)
    </example_code>
    
    Task: a deadlock free mutual exclusion algorithm
  # evaluator_system_message: |
  #   You are an expert PlusCal/TLA+ reviewer.
  #   Judge programs strictly on whether all invariants hold without any edits to
  #   their definitions. Responses that change invariant text or names should be
  #   considered invalid.

  # Number of examples to include in the prompt
  num_top_programs: 1 # Number of top-performing programs to include
  num_diverse_programs: 2 # Number of diverse programs to include

  # Template stochasticity
  use_template_stochasticity: false # Use random variations in templates for diversity
  template_variations: # Different phrasings for parts of the template
    improvement_suggestion:
      - "Here's how we could improve this code:"
      - "I suggest the following improvements:"
      - "We can enhance this code by:"

  # Artifact rendering
  include_artifacts: true # Include execution outputs/errors in prompt
  max_artifact_bytes: 20480 # Maximum artifact size in bytes (20KB default)
  artifact_security_filter: true # Apply security filtering to artifacts

  # Feature extraction and program labeling thresholds
  # These control how the LLM perceives and categorizes programs
  suggest_simplification_after_chars: 500 # Suggest simplifying if program exceeds this many characters
  include_changes_under_chars: 100 # Include change descriptions in features if under this length
  concise_implementation_max_lines: 10 # Label as "concise" if program has this many lines or fewer
  comprehensive_implementation_min_lines: 50 # Label as "comprehensive" if program has this many lines or more

  # Note: meta-prompting features are not yet implemented

# Database configuration
database:
  # General settings
  db_path: null # Path to persist database (null = in-memory only)
  in_memory: true # Keep database in memory for faster access
  log_prompts: true # If true, log all prompts and responses into the database

  # Evolutionary parameters
  population_size: 1000 # Maximum number of programs to keep in memory
  archive_size: 100 # Size of elite archive
  num_islands: 5 # Number of islands for island model (separate populations)

  # Island-based evolution parameters
  # Islands provide diversity by maintaining separate populations that evolve independently.
  # Migration periodically shares the best solutions between adjacent islands.
  migration_interval: 50 # Migrate between islands every N generations
  migration_rate: 0.1 # Fraction of top programs to migrate (0.1 = 10%)

  # Selection parameters
  elite_selection_ratio: 0.1 # Ratio of elite programs to select
  exploration_ratio: 0.2 # Ratio of exploration vs exploitation
  exploitation_ratio: 0.7 # Ratio of exploitation vs random selection
  # Note: diversity_metric is fixed to "edit_distance" (feature_based not implemented)

  # Feature map dimensions for MAP-Elites
  # Default if not specified: ["complexity", "diversity"]
  #
  # Built-in features (always available, computed by OpenEvolve):
  #   - "complexity": Code length
  #   - "diversity": Code structure diversity
  #
  # You can mix built-in features with custom metrics from your evaluator:
  feature_dimensions: # Dimensions for MAP-Elites feature map (for diversity, NOT fitness)
    - "complexity" # Code length (built-in)
    - "diversity" # Code diversity (built-in)
  # Example with custom features:
  # feature_dimensions:
  #   - "performance"                 # Must be returned by your evaluator
  #   - "correctness"                 # Must be returned by your evaluator
  #   - "memory_efficiency"           # Must be returned by your evaluator

  # Number of bins per dimension
  # Can be a single integer (same for all dimensions) or a dict
  feature_bins: 10 # Number of bins per dimension
  # Example of per-dimension configuration:
  # feature_bins:
  #   complexity: 10                  # 10 bins for complexity
  #   diversity: 15                   # 15 bins for diversity
  #   performance: 20                 # 20 bins for custom metric

  diversity_reference_size: 20 # Size of reference set for diversity calculation

# Evaluator configuration
evaluator:
  # Fitness calculation: Uses 'combined_score' if available, otherwise averages
  # all metrics EXCEPT those listed in database.feature_dimensions

  # General settings
  timeout: 3000 # Maximum evaluation time in seconds
  max_retries: 3 # Maximum number of retries for evaluation

  # Note: resource limits (memory_limit_mb, cpu_limit) are not yet implemented

  # Evaluation strategies
  cascade_evaluation: true # Use cascade evaluation to filter bad solutions early
  cascade_thresholds: # Thresholds for advancing to next evaluation stage
    - 0.5 # First stage threshold
    - 0.75 # Second stage threshold
    - 0.9 # Third stage threshold

  # Parallel evaluation
  parallel_evaluations: 2 # Number of parallel evaluations
  # Note: distributed evaluation is not yet implemented

  # LLM-based feedback (experimental)
  use_llm_feedback: false # Use LLM to evaluate code quality
  llm_feedback_weight: 0.1 # Weight for LLM feedback in final score

# Evolution trace configuration
# Logs detailed traces of program evolution for RL training and analysis
evolution_trace:
  enabled: false # Enable evolution trace logging
  format: "jsonl" # Output format: 'jsonl', 'json', or 'hdf5'
  include_code: true # Include full program code in traces
  include_prompts: true # Include prompts and LLM responses
  output_path: null # Path for trace output (defaults to output_dir/evolution_trace.{format})
  buffer_size: 10 # Number of traces to buffer before writing
  compress: false # Compress output file (jsonl only)
