# OpenEvolve Default Configuration
# This file contains all available configuration options with sensible defaults
# You can use this as a template for your own configuration

# General settings
max_iterations: 40 # Maximum number of evolution iterations
checkpoint_interval: 1 # Save checkpoints every N iterations
log_level: "INFO" # Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
log_dir: null # Custom directory for logs (default: output_dir/logs)
random_seed: 42 # Random seed for reproducibility (null = random, 42 = default)
file_suffix: ".tla"
language: "tla"

# Evolution settings
diff_based_evolution: true # Use diff-based evolution (true) or full rewrites (false)
max_code_length: 500000 # Maximum allowed code length in characters

# Early stopping settings
early_stopping_patience: null # Stop after N iterations without improvement (null = disabled)
convergence_threshold: 0.001 # Minimum improvement required to reset patience counter
early_stopping_metric: "combined_score" # Metric to track for early stopping

# LLM configuration
llm:
  # Models for evolution
  models:
    # List of available models with their weights
    - name: "gpt-5"
      weight: 1

  # Models for LLM feedback
  evaluator_models:
    # List of available models with their weights
    - name: "gpt-5"
      weight: 1

  # Generation parameters
  temperature: 0.7 # Temperature for generation (higher = more creative)
  top_p: 0.95 # Top-p sampling parameter
  max_tokens: 10000 # Maximum tokens to generate

  # Request parameters
  timeout: 120 # Timeout for API requests in seconds
  retries: 3 # Number of retries for failed requests
  retry_delay: 10 # Delay between retries in seconds

# Prompt configuration
prompt:
  template_dir: null # Custom directory for prompt templates
  system_message: |
    You are an expert PlusCal/TLA+ engineer evolving a specification.

    Strict TLC-compatible output requirements:
    - Modify only the PlusCal algorithm inside the `(* --algorithm ... *)` section, strictly within the EVOLVE-BLOCK if present.
    - Follow the user prompt format for expressing edits; do not include explanations.
    - Do NOT change the module header, EXTENDS, CONSTANT(S), any TLA+ operators, Init/Next/Spec, or invariant definitions.
    - Do NOT rename or alter any identifiers referenced by the TLC configuration or invariants (variables, process names, or labels such as `CS`).

    Diff-based editing rules (apply minimal diffs inside EVOLVE-BLOCK):
    - Only change lines between `\* EVOLVE-BLOCK-START` and `\* EVOLVE-BLOCK-END` in the provided program file.
    - Keep the algorithm name unchanged unless strictly necessary to fix translation or model checking errors.
    - Preserve existing labels and their spellings; add new labels only when needed.
    - Avoid reformatting or renaming unchanged code; keep diffs as small as possible.
    - Do not add or remove the EVOLVE-BLOCK markers themselves.

    PlusCal syntax quick reference (TLC translator-friendly):
    - Use braces style with parentheses around conditions: `while (COND) { ... }`, `if (COND) { ... } else { ... };`
    - Do NOT use `begin`/`end` or `end algorithm`; always use `{` and `}` for blocks and the algorithm body.
    - Terminate every statement with `;` (including `goto`, assignments, `skip`, `await`, and `if`/`else` blocks).
    - Assign with `:=`. In `variables`, initialize with `=` or choose with `\in` (e.g., `variables b = [i \in Proc |-> TRUE], k \in Proc;`). Local process vars use `variable x ;`.
    - Process header: `process (P \in Proc)` and index per-process state with `self` (e.g., `b[self]`).
    - Labels: `L1:` at statement start; jump via `goto L1;`. Preserve invariant-dependent labels (e.g., `CS`).
    - Operators: booleans `TRUE`/`FALSE`, not `~`, inequality `#`, membership `\in`, set difference `\`, and array indexing `a[i]`.
    - `with` binding: `with (x \in S) { ... }`. Example loops: `while (TRUE) { ... }`, `while (temp # {}) { ... }`.
    - Arrays/functions: `[i \in S |-> v]` comprehensions; update elements with `a[i] := v;`.
    - Use only valid PlusCal control flow: `while`, `if/else`, `with`, `either/or`, `await`, labeled statements, `goto`.

    Name-safety (avoid collisions with translator/TLC names):
    - Do NOT declare any variable or label named `pc`, `vars`, `ProcSet`, `defaultInitValue`, `Init`, `Next`, `Spec`, or any identifier prefixed with `TLATrans_`.
    - Do NOT define TLA+ operators, constants, or macros outside the algorithm.

    TLC compatibility:
    - The program must translate with `pcal.trans` without errors.
    - It must work with `SPECIFICATION Spec` and the existing `INVARIANTS` from the `.cfg` file.
    - Keep any labels and variable names that invariants depend on unchanged (e.g., keep `CS` if the invariant checks it).


    This is an example of syntactically correct PlusCal code:
    <example_code>
    (* --algorithm Count
    { variables x = 0;
      { Loop: while (x < 10) {
        Add: x := x + 1;
        }
      }
    } *)
    </example_code>

    IMPORTANT: Ignore the Properties and Definitions below the Algorithm block. These are only there to evalualte later whether the implementation was correct. You should only write pascal code using the Variables from the top, to implement the Transfer over the river and a sequence that solves the problem!
    So the goal is to implement a solution to the problem that is a concrete PlusCal implementation of the solution.

    Implement it with well structured code. Use procedures to avoid code duplication, and thereby give the output program a good structure.
    Important: Dont use any asserts, you should not generate pluscal solutioin to test invariants. But rahter you should implement the concrete solution.
    Task: solve the missionaries and cannibals problem
  # evaluator_system_message: |
  #   You are an expert PlusCal/TLA+ reviewer.
  #   Judge programs strictly on whether all invariants hold without any edits to
  #   their definitions. Responses that change invariant text or names should be
  #   considered invalid.

  # Number of examples to include in the prompt
  num_top_programs: 1 # Number of top-performing programs to include
  num_diverse_programs: 3 # Number of diverse programs to include

  # Template stochasticity
  use_template_stochasticity: false # Use random variations in templates for diversity
  template_variations: # Different phrasings for parts of the template
    improvement_suggestion:
      - "Here's how we could improve this code:"
      - "I suggest the following improvements:"
      - "We can enhance this code by:"

  # Artifact rendering
  include_artifacts: true # Include execution outputs/errors in prompt
  max_artifact_bytes: 20480 # Maximum artifact size in bytes (20KB default)
  artifact_security_filter: true # Apply security filtering to artifacts

  # Feature extraction and program labeling thresholds
  # These control how the LLM perceives and categorizes programs
  suggest_simplification_after_chars: 500 # Suggest simplifying if program exceeds this many characters
  include_changes_under_chars: 100 # Include change descriptions in features if under this length
  concise_implementation_max_lines: 10 # Label as "concise" if program has this many lines or fewer
  comprehensive_implementation_min_lines: 50 # Label as "comprehensive" if program has this many lines or more

  # Note: meta-prompting features are not yet implemented

# Database configuration
database:
  # General settings
  db_path: null # Path to persist database (null = in-memory only)
  in_memory: true # Keep database in memory for faster access
  log_prompts: true # If true, log all prompts and responses into the database

  # Evolutionary parameters
  population_size: 1000 # Maximum number of programs to keep in memory
  archive_size: 100 # Size of elite archive
  num_islands: 5 # Number of islands for island model (separate populations)

  # Island-based evolution parameters
  # Islands provide diversity by maintaining separate populations that evolve independently.
  # Migration periodically shares the best solutions between adjacent islands.
  migration_interval: 50 # Migrate between islands every N generations
  migration_rate: 0.1 # Fraction of top programs to migrate (0.1 = 10%)

  # Selection parameters
  elite_selection_ratio: 0.1 # Ratio of elite programs to select
  exploration_ratio: 0.2 # Ratio of exploration vs exploitation
  exploitation_ratio: 0.7 # Ratio of exploitation vs random selection
  # Note: diversity_metric is fixed to "edit_distance" (feature_based not implemented)

  # Feature map dimensions for MAP-Elites
  # Default if not specified: ["complexity", "diversity"]
  #
  # Built-in features (always available, computed by OpenEvolve):
  #   - "complexity": Code length
  #   - "diversity": Code structure diversity
  #
  # You can mix built-in features with custom metrics from your evaluator:
  feature_dimensions: # Dimensions for MAP-Elites feature map (for diversity, NOT fitness)
    - "complexity" # Code length (built-in)
    - "diversity" # Code diversity (built-in)
  # Example with custom features:
  # feature_dimensions:
  #   - "performance"                 # Must be returned by your evaluator
  #   - "correctness"                 # Must be returned by your evaluator
  #   - "memory_efficiency"           # Must be returned by your evaluator

  # Number of bins per dimension
  # Can be a single integer (same for all dimensions) or a dict
  feature_bins: 10 # Number of bins per dimension
  # Example of per-dimension configuration:
  # feature_bins:
  #   complexity: 10                  # 10 bins for complexity
  #   diversity: 15                   # 15 bins for diversity
  #   performance: 20                 # 20 bins for custom metric

  diversity_reference_size: 20 # Size of reference set for diversity calculation

# Evaluator configuration
evaluator:
  # Fitness calculation: Uses 'combined_score' if available, otherwise averages
  # all metrics EXCEPT those listed in database.feature_dimensions

  # General settings
  timeout: 3000 # Maximum evaluation time in seconds
  max_retries: 3 # Maximum number of retries for evaluation

  # Note: resource limits (memory_limit_mb, cpu_limit) are not yet implemented

  # Evaluation strategies
  cascade_evaluation: true # Use cascade evaluation to filter bad solutions early
  cascade_thresholds: # Thresholds for advancing to next evaluation stage
    - 0.5 # First stage threshold
    - 0.75 # Second stage threshold
    - 0.9 # Third stage threshold

  # Parallel evaluation
  parallel_evaluations: 2 # Number of parallel evaluations
  # Note: distributed evaluation is not yet implemented

  # LLM-based feedback (experimental)
  use_llm_feedback: false # Use LLM to evaluate code quality
  llm_feedback_weight: 0.1 # Weight for LLM feedback in final score

# Evolution trace configuration
# Logs detailed traces of program evolution for RL training and analysis
evolution_trace:
  enabled: false # Enable evolution trace logging
  format: "jsonl" # Output format: 'jsonl', 'json', or 'hdf5'
  include_code: true # Include full program code in traces
  include_prompts: true # Include prompts and LLM responses
  output_path: null # Path for trace output (defaults to output_dir/evolution_trace.{format})
  buffer_size: 10 # Number of traces to buffer before writing
  compress: false # Compress output file (jsonl only)
